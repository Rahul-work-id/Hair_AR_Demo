<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>MediaPipe + Babylon.js AR Hat</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/loaders/babylon.glTF2FileLoader.js"></script>
    <style>
        html, body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: black;
        }

        #video {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            object-fit: cover;
            z-index: 0;
            transform: scaleX(-1);
        }

        canvas {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
            width: 100vw;
            height: 100vh;
            pointer-events: none;
        }
    </style>
</head>

<body>
    <video id="video" autoplay playsinline muted></video>
    <canvas id="renderCanvas"></canvas>
    <div id="debug" style="
        position: absolute;
        top: 100px;
        left: 100px;
        color: lime;
        font-family: monospace;
        background: rgba(0,0,0,0.5);
        padding: 8px;
        border-radius: 6px;
        font-size: 16px;
        z-index: 2;">
        Loading...
    </div>

    <script>
        const canvas = document.getElementById("renderCanvas");
        const engine = new BABYLON.Engine(canvas, true);
        const scene = new BABYLON.Scene(engine);

        scene.clearColor = new BABYLON.Color4(0, 0, 0, 0);

        const camera = new BABYLON.FreeCamera("cam", new BABYLON.Vector3(0, 0, -10), scene);
        camera.setTarget(BABYLON.Vector3.Zero());
        camera.fov = 1.0;
        camera.minZ = 0.1;
        camera.maxZ = 1000;

        const light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), scene);

        let hat;

        BABYLON.SceneLoader.ImportMesh("", "./", "hard_hat.glb", scene, (meshes) => {
            hat = meshes[0];
            hat.position.z = 1;
            hat.scaling.set(1, 1, 1);
        });

        engine.runRenderLoop(() => scene.render());

        const videoElement = document.getElementById("video");

        const faceMesh = new FaceMesh({
            locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`
        });

        faceMesh.setOptions({
            maxNumFaces: 1,
            refineLandmarks: true,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        function getHeadQuaternion(landmarks) {
            const leftEyeInner = landmarks[133];
            const rightEyeInner = landmarks[362];
            const noseTip = landmarks[1];
            const chin = landmarks[152];

            const dx = rightEyeInner.x - leftEyeInner.x;
            const dy = rightEyeInner.y - leftEyeInner.y;
            const yawRad = Math.atan2(dy, dx);

            const pitchDy = noseTip.y - chin.y;
            const pitchDz = noseTip.z - chin.z;
            const pitchRad = Math.atan2(pitchDy, pitchDz);

            const rollDx = rightEyeInner.x - leftEyeInner.x;
            const rollDy = rightEyeInner.y - leftEyeInner.y;
            const rollRad = Math.atan2(rollDy, rollDx);

            const quaternion = BABYLON.Quaternion.RotationYawPitchRoll(
                -yawRad + Math.PI / 2,  // Yaw
                pitchRad,               // Pitch
                -rollRad                // Roll
            );

            return {
                quaternion,
                yawDeg: BABYLON.Tools.ToDegrees(yawRad),
                pitchDeg: BABYLON.Tools.ToDegrees(pitchRad),
                rollDeg: BABYLON.Tools.ToDegrees(rollRad)
            };
        }

        faceMesh.onResults(results => {
            if (results.multiFaceLandmarks && results.multiFaceLandmarks.length > 0) {
                const landmarks = results.multiFaceLandmarks[0];
                const forehead = landmarks[10];
                const leftEye = landmarks[33];
                const rightEye = landmarks[263];

                const x = -(forehead.x - 0.5) * 10;
                const y = -(forehead.y - 0.5) * 10;
                const zf = (forehead.z) * 30;

                const dx = rightEye.x - leftEye.x;
                const dy = rightEye.y - leftEye.y;
                const dz = rightEye.z - leftEye.z;
                const eyeDist = Math.sqrt(dx * dx + dy * dy + dz * dz);

                const baseEyeDist = 0.06;
                const z = (baseEyeDist / eyeDist) * 3;

                if (hat) {
                    hat.position.set(x, y + 0.3, zf);

                    const { quaternion, yawDeg, pitchDeg, rollDeg } = getHeadQuaternion(landmarks);

                    hat.rotationQuaternion = quaternion;

                    const debugText = `
                        üëÅÔ∏è Eye Distance: ${eyeDist.toFixed(4)}<br>
                        üß† Forehead Z (raw): ${forehead.z.toFixed(4)}<br>
                        üîÑ Yaw: ${yawDeg.toFixed(2)}¬∞<br>
                        üîÑ Pitch: ${pitchDeg.toFixed(2)}¬∞<br>
                        üîÑ Roll: ${rollDeg.toFixed(2)}¬∞
                    `;
                    document.getElementById('debug').innerHTML = debugText;
                }
            }
        });

        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => {
                await faceMesh.send({ image: videoElement });
            },
            width: 640,
            height: 480
        });

        cameraUtils.start();
    </script>
</body>

</html>
