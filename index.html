<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>MediaPipe + Babylon.js AR Hat</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/loaders/babylon.glTF2FileLoader.js"></script>
    <style>
        html,
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: black;
        }

        #video {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            object-fit: cover;
            z-index: 0;
            transform: scaleX(-1);
        }

        canvas {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
            width: 100vw;
            height: 100vh;
            pointer-events: none;
        }
    </style>
</head>

<body>
    <video id="video" autoplay playsinline muted></video>
    <canvas id="renderCanvas"></canvas>
    <div id="debug" style="
        position: absolute;
        top: 100px;
        left: 100px;
        color: lime;
        font-family: monospace;
        background: rgba(0,0,0,0.5);
        padding: 8px;
        border-radius: 6px;
        font-size: 50px;
        z-index: 2;">
        Loading...
    </div>

    <script>
        const canvas = document.getElementById("renderCanvas");
        const engine = new BABYLON.Engine(canvas, true);
        const scene = new BABYLON.Scene(engine);

        // ‚úÖ Transparent background so camera feed shows through
        scene.clearColor = new BABYLON.Color4(0, 0, 0, 0);

        // ‚úÖ Perspective camera
        const camera = new BABYLON.FreeCamera("cam", new BABYLON.Vector3(0, 0, -10), scene);
        camera.setTarget(BABYLON.Vector3.Zero());
        camera.fov = 1.0;
        camera.minZ = 0.1;
        camera.maxZ = 1000;
        camera.mode = BABYLON.Camera.PERSPECTIVE_CAMERA;

        // ‚úÖ Fixed typo in light creation
        const light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), scene);

        let hat;

        BABYLON.SceneLoader.ImportMesh("", "./", "hard_hat.glb", scene, (meshes) => {
            hat = meshes[0];
            hat.position.z = 1;
            hat.scaling.set(1, 1, 1);
        });
        hat.renderingGroupId = 1; // Render after occluder (which is 0)

        engine.runRenderLoop(() => scene.render());

        const videoElement = document.getElementById("video");

        const faceMesh = new FaceMesh({
            locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`
        });

        faceMesh.setOptions({
            maxNumFaces: 1,
            refineLandmarks: true,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        let occluder;

        function createOccluderMesh(scene) {
            const faceIndices = [
                // Define triangle indices based on MediaPipe landmarks.
                // A simple front-face mask (forehead, cheeks, chin)
                [10, 338, 297], [10, 297, 332], [10, 332, 284], [10, 284, 251], [10, 251, 389],
                [10, 389, 264], [10, 264, 454], [10, 454, 323], [10, 323, 361], [10, 361, 288]
            ];

            const faceVertexData = new BABYLON.VertexData();
            faceVertexData.indices = [];
            faceVertexData.positions = [];

            const mesh = new BABYLON.Mesh("occluder", scene);
            mesh.alwaysSelectAsActiveMesh = true;
            mesh.renderingGroupId = 0;  

            faceVertexData.applyToMesh(mesh, true);

            const material = new BABYLON.StandardMaterial("occluderMat", scene);
            material.alpha = 0; // Fully transparent
            material.disableDepthWrite = false;
            material.forceDepthWrite = true; // Write to depth buffer
            material.backFaceCulling = false;
            mesh.material = material;

            occluder = mesh;
            occluder.setEnabled(false); // initially hidden

            return { mesh, faceIndices };
        }



        faceMesh.onResults(results => {
            if (results.multiFaceLandmarks && results.multiFaceLandmarks.length > 0) {
                const landmarks = results.multiFaceLandmarks[0];

                const forehead = landmarks[10];
                const leftEye = landmarks[33];
                const rightEye = landmarks[263];

                const x = -(forehead.x - 0.5) * 10;
                const y = -(forehead.y - 0.4) * 10;
                const zf = (forehead.z + 0.5) * 3;

                const dx = rightEye.x - leftEye.x;
                const dy = rightEye.y - leftEye.y;
                const dz = rightEye.z - leftEye.z;
                const eyeDist = Math.sqrt(dx * dx + dy * dy + dz * dz);

                const baseEyeDist = 0.06;
                const z = (baseEyeDist / eyeDist) * 3;

                if (!occluder) {
                    const { mesh, faceIndices } = createOccluderMesh(scene);
                    occluder = mesh;
                    occluder.faceIndices = faceIndices;
                }
                
                const positions = [];
                occluder.faceIndices.forEach(tri => {
                    tri.forEach(index => {
                        const pt = landmarks[index];
                        positions.push(-(pt.x - 0.5) * 10, -(pt.y - 0.5) * 10, pt.z * 30);
                    });
                });
                
                occluder.setEnabled(true);
                occluder.updateVerticesData(BABYLON.VertexBuffer.PositionKind, positions);
                occluder.isVisible = false;
                

                if (hat) {
                    hat.position.set(x, y + 0.3, zf);

                    // LANDMARKS
                    const leftEye = landmarks[33];
                    const rightEye = landmarks[263];
                    const forehead = landmarks[10];
                    const chin = landmarks[152];

                    // --- ROTATION ESTIMATION ---

                    // ‚û§ 1. YAW (Y-axis, turning left/right)
                    const yawRad = Math.atan2(rightEye.x - leftEye.x, rightEye.z - leftEye.z);
                    const yawDeg = BABYLON.Tools.ToDegrees(yawRad);

                    // ‚û§ 2. PITCH (X-axis, looking up/down)
                    const pitchRad = Math.atan2(forehead.y - chin.y, forehead.z - chin.z);
                    const pitchDeg = BABYLON.Tools.ToDegrees(pitchRad);

                    // ‚û§ 3. ROLL (Z-axis, tilting sideways)
                    const rollRad = Math.atan2(rightEye.y - leftEye.y, rightEye.x - leftEye.x);
                    const rollDeg = BABYLON.Tools.ToDegrees(rollRad);

                    // Hat's current rotation
                    const hatRotX = BABYLON.Tools.ToDegrees(hat.rotation.x).toFixed(2);
                    const hatRotY = BABYLON.Tools.ToDegrees(hat.rotation.y).toFixed(2);
                    const hatRotZ = BABYLON.Tools.ToDegrees(hat.rotation.z).toFixed(2);

                    const quaternion = BABYLON.Quaternion.RotationYawPitchRoll(
                        BABYLON.Tools.ToRadians(-(yawDeg + 90)),  // Yaw
                        BABYLON.Tools.ToRadians(-(pitchDeg + 90)),               // Pitch
                        BABYLON.Tools.ToRadians(-rollDeg)               // Roll
                    );

                    hat.rotationQuaternion = quaternion;


                    // üñ•Ô∏è Debug info
                    const debugText = `
                        üëÅÔ∏è Eye Distance: ${eyeDist.toFixed(4)}<br>
                        üß† Forehead Z (raw): ${forehead.z.toFixed(4)}<br>
                        ‚Ü™Ô∏è Head Rotation:<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;Yaw (Y): ${yawDeg.toFixed(2)}¬∞<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;Pitch (X): ${pitchDeg.toFixed(2)}¬∞<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;Roll (Z): ${rollDeg.toFixed(2)}¬∞<br>
                        üé© Hat Rotation:<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;X: ${hatRotX}¬∞, Y: ${hatRotY}¬∞, Z: ${hatRotZ}¬∞
                         `;
                    document.getElementById('debug').innerHTML = debugText;

                    // Apply rotation to the hat
                    //hat.rotation.x = BABYLON.Tools.ToRadians(pitchDeg + 90);     // pitch offset to neutral (looking forward)
                    //hat.rotation.y = BABYLON.Tools.ToRadians(-(yawDeg - 90));     // invert yaw so right is positive
                    //hat.rotation.z = BABYLON.Tools.ToRadians(-rollDeg);  
                }
            }
        });

        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => {
                await faceMesh.send({ image: videoElement });
            },
            width: 640,
            height: 480
        });

        cameraUtils.start();
    </script>
</body>

</html>