<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>MediaPipe + Babylon.js AR Hat</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/loaders/babylon.glTF2FileLoader.js"></script>
    <style>
        html,
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: black;
        }

        #video {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            object-fit: cover;
            z-index: 0;
            transform: scaleX(-1);
        }

        canvas {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
            width: 100vw;
            height: 100vh;
            pointer-events: none;
        }
    </style>
</head>

<body>
    <video id="video" autoplay playsinline muted></video>
    <canvas id="renderCanvas"></canvas>
    <div id="debug" style="
        position: absolute;
        top: 100px;
        left: 100px;
        color: lime;
        font-family: monospace;
        background: rgba(0,0,0,0.5);
        padding: 8px;
        border-radius: 6px;
        z-index: 2;">
        Loading...
    </div>

    <script>
        const canvas = document.getElementById("renderCanvas");
        const engine = new BABYLON.Engine(canvas, true);
        const scene = new BABYLON.Scene(engine);

        // ‚úÖ Transparent background so camera feed shows through
        scene.clearColor = new BABYLON.Color4(0, 0, 0, 0);

        // ‚úÖ Perspective camera
        const camera = new BABYLON.FreeCamera("cam", new BABYLON.Vector3(0, 0, -10), scene);
        camera.setTarget(BABYLON.Vector3.Zero());
        camera.fov = 1.0;
        camera.minZ = 0.1;
        camera.maxZ = 1000;
        camera.mode = BABYLON.Camera.PERSPECTIVE_CAMERA;

        // ‚úÖ Fixed typo in light creation
        const light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), scene);

        let hat;

        BABYLON.SceneLoader.ImportMesh("", "./", "hard_hat.glb", scene, (meshes) => {
            hat = meshes[0];
            hat.position.z = 1;
            hat.scaling.set(1, 1, 1);
        });

        engine.runRenderLoop(() => scene.render());

        const videoElement = document.getElementById("video");

        const faceMesh = new FaceMesh({
            locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`
        });

        faceMesh.setOptions({
            maxNumFaces: 1,
            refineLandmarks: true,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        faceMesh.onResults(results => {
            if (results.multiFaceLandmarks && results.multiFaceLandmarks.length > 0) {
                const landmarks = results.multiFaceLandmarks[0];

                const forehead = landmarks[10];
                const leftEye = landmarks[33];
                const rightEye = landmarks[263];

                const x = -(forehead.x - 0.5) * 10;
                const y = -(forehead.y - 0.5) * 10;

                const dx = rightEye.x - leftEye.x;
                const dy = rightEye.y - leftEye.y;
                const dz = rightEye.z - leftEye.z;
                const eyeDist = Math.sqrt(dx * dx + dy * dy + dz * dz);

                const baseEyeDist = 0.06;
                const z = (baseEyeDist / eyeDist) * 100;

                if (hat) {
                    hat.position.set(x, y + 0.3, z);

                    // ‚úÖ Show debug values for Z axis
                    const debugText = `
                        üëÅÔ∏è Eye Distance: ${eyeDist.toFixed(4)}<br>
                        üß† Forehead Z (raw): ${forehead.z.toFixed(4)}<br>
                        üé© Hat Z Position: ${hat.position.z.toFixed(4)}
                    `;
                    document.getElementById('debug').innerHTML = debugText;
                }
            }
        });

        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => {
                await faceMesh.send({ image: videoElement });
            },
            width: 640,
            height: 480
        });

        cameraUtils.start();
    </script>
</body>

</html>
