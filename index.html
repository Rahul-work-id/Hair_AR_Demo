<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>MediaPipe + Babylon.js AR Hat</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/loaders/babylon.glTF2FileLoader.js"></script>
    <style>
        html,
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: black;
        }

        #video {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            object-fit: cover;
            z-index: 0;
            transform: scaleX(-1);
        }

        canvas {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
            width: 100vw;
            height: 100vh;
            pointer-events: none;
        }
    </style>
</head>

<body>
    <video id="video" autoplay playsinline muted></video>
    <canvas id="renderCanvas"></canvas>
    <div id="debug" style="
        position: absolute;
        top: 100px;
        left: 100px;
        color: lime;
        font-family: monospace;
        background: rgba(0,0,0,0.5);
        padding: 8px;
        border-radius: 6px;
        font-size: 50px;
        z-index: 2;">
        Loading...
    </div>

    <script>
        const canvas = document.getElementById("renderCanvas");
        const engine = new BABYLON.Engine(canvas, true);
        const scene = new BABYLON.Scene(engine);

        // ‚úÖ Transparent background so camera feed shows through
        scene.clearColor = new BABYLON.Color4(0, 0, 0, 0);

        // ‚úÖ Perspective camera
        const camera = new BABYLON.FreeCamera("cam", new BABYLON.Vector3(0, 0, -10), scene);
        camera.setTarget(BABYLON.Vector3.Zero());
        camera.fov = 1.0;
        camera.minZ = 0.1;
        camera.maxZ = 1000;
        camera.mode = BABYLON.Camera.PERSPECTIVE_CAMERA;

        // ‚úÖ Fixed typo in light creation
        const light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), scene);

        let hat;

        BABYLON.SceneLoader.ImportMesh("", "./", "hard_hat.glb", scene, (meshes) => {
            hat = meshes[0];
            hat.position.z = 1;
            hat.scaling.set(1.25, 1.25, 1.25);
            hat.getChildMeshes().forEach(m => {
                if (m.material) {
                    m.material.alpha = 1.0;
                    m.material.transparencyMode = BABYLON.Material.MATERIAL_OPAQUE;
                }
            });

            //hat.isOccluded = true;
            hat.renderingGroupId = 1; // Render after occluder (which is 0)
        });


        engine.runRenderLoop(() => scene.render());

        const videoElement = document.getElementById("video");
        const videoWidth = videoElement.videoWidth;
        const videoHeight = videoElement.videoHeight;
        const faceMesh = new FaceMesh({
            locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`
        });

        faceMesh.setOptions({
            maxNumFaces: 1,
            refineLandmarks: true,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5,
            selfieMode: true
        });

        let occluder;

        function createOccluderMesh(scene) {
            const faceIndices = [
                // Define triangle indices based on MediaPipe landmarks
                [10, 338, 297], [10, 297, 332], [10, 332, 284], [10, 284, 251], [10, 251, 389],
                [10, 389, 264], [10, 264, 454], [10, 454, 323], [10, 323, 361], [10, 361, 288]
            ];

            const positions = [];
            const indices = [];

            let index = 0;
            faceIndices.forEach(tri => {
                tri.forEach(i => {
                    positions.push(0, 0, 0); // placeholder, will update per frame
                });
                indices.push(index, index + 1, index + 2);
                index += 3;
            });

            const vertexData = new BABYLON.VertexData();
            vertexData.positions = positions;
            vertexData.indices = indices;

            const mesh = new BABYLON.Mesh("occluder", scene);
            vertexData.applyToMesh(mesh);

            const mat = new BABYLON.StandardMaterial("occluderMat", scene);
            mat.alpha = .5; // Fully transparent
            mat.diffuseColor = new BABYLON.Color3(1, 0, 0); // Red for visibility
            mat.backFaceCulling = false;
            //mat.forceDepthWrite = true;
            //mat.disableDepthWrite = false; // allow depth writing

            mesh.material = mat;
            mesh.renderingGroupId = 0;
            mesh.setEnabled(false);

            return { mesh, faceIndices };
        }


        //const sphere = BABYLON.MeshBuilder.CreateSphere("marker", { diameter: 1 }, scene);

        //-----------------------------------------occluder-------------------------------------------------
        /*const occluderSphere = BABYLON.MeshBuilder.CreateSphere("occluderSphere", { diameter: 2 }, scene);
        occluderSphere.isVisible = true;

        const occluderMaterial = new BABYLON.PBRMaterial("")



        occluderSphere.material = occluderMaterial;
        occluderMaterial.disableColorWrite = true
        occluderMaterial.needDepthPrePass = true
        occluderSphere.renderingGroupId = 0;*/

        //------------------------------------------------------------------------------------------------
        // Move to foreground rendering group
        //occluderSphere.renderingGroupId = 0;

        let landmarkSpheres = [];

        function createLandmarkSpheres(scene, count) {
            const spheres = [];
            for (let i = 0; i < count; i++) {
                const sphere = BABYLON.MeshBuilder.CreateSphere(`lm_${i}`, { diameter: 0.1 }, scene);
                const mat = new BABYLON.StandardMaterial(`mat_${i}`, scene);
                mat.diffuseColor = new BABYLON.Color3(0, 1, 0); // green
                sphere.material = mat;
                sphere.isPickable = false;
                spheres.push(sphere);
            }
            return spheres;
        }

        // Create once at startup
        landmarkSpheres = createLandmarkSpheres(scene, 468);


        faceMesh.onResults(results => {
            if (results.multiFaceLandmarks && results.multiFaceLandmarks.length > 0) {
                const landmarks = results.multiFaceLandmarks[0];

                // Update sphere positions
                for (let i = 0; i < landmarkSpheres.length; i++) {
                    const lm = landmarks[i];
                    const scale = 12; // Try different values like 10, 15 depending on scene scale
                    const x = (lm.x - 0.5) * scale;
                    const y = -(lm.y - 0.5) * scale;
                    const z = -(lm.z) * scale; // Negative to push into screen (depth)

                    landmarkSpheres[i].position.set(x, y, z);
                }

                const leftEye = landmarks[33];
                const rightEye = landmarks[263];
                const forehead = landmarks[10];
                const chin = landmarks[152];

                const faceCenter = landmarks[10]; // forehead (or average eyes + forehead for center)
                const hatX = -(faceCenter.x - 0.5) * 10;
                const hatY = -(faceCenter.y - 0.5) * 10 + 0.5;
                const hatZ = (faceCenter.z + 0.5) * 10;

                const x = (forehead.x - 0.5) * 10;
                const y = -(forehead.y - 0.5) * 10;
                const zf = -(forehead.z - 0.5) * 10;

                const dx = rightEye.x - leftEye.x;
                const dy = rightEye.y - leftEye.y;
                const dz = rightEye.z - leftEye.z;
                const eyeDist = Math.sqrt(dx * dx + dy * dy + dz * dz);

                const baseEyeDist = 0.06;
                const depthZ = (leftEye.z + rightEye.z) / 2;
                const z = (depthZ * 30) ;  // scale to Babylon units


                const x_oc = -(forehead.x - 0.5) * 10;
                const y_oc = -(forehead.y - 0.5) * 10;
                const z_oc = forehead.z * 30;

                //------------------------------facemesh--------------------------------------------------

                //-------------------------------------------------------------------------------

                //occluderSphere.position.set(x_oc, y_oc + 0.5, z);

                //occluderSphere.isVisible = true;
                //occluderSphere.renderingGroupId = 0;
                if (hat) {
                    hat.position.set(x, y + 0.3, zf);
                    //hat.position = BABYLON.Vector3.Lerp(hat.position, new BABYLON.Vector3(x, y + 0.3, z), 0.2);
                    hat.renderingGroupId = 1;

                    const scaleFactor = (eyeDist / baseEyeDist)/1.25;
                    hat.scaling.set(scaleFactor, scaleFactor, scaleFactor);

                    //sphere.position.set(x, y + 0.6, z);
                    // LANDMARKS


                    // --- ROTATION ESTIMATION ---

                    // ‚û§ 1. YAW (Y-axis, turning left/right)
                    const yawRad = Math.atan2(rightEye.x - leftEye.x, rightEye.z - leftEye.z);
                    const yawDeg = BABYLON.Tools.ToDegrees(yawRad);

                    // ‚û§ 2. PITCH (X-axis, looking up/down)
                    const pitchRad = Math.atan2(forehead.y - chin.y, forehead.z - chin.z);
                    const pitchDeg = BABYLON.Tools.ToDegrees(pitchRad);

                    // ‚û§ 3. ROLL (Z-axis, tilting sideways)
                    const rollRad = Math.atan2(rightEye.y - leftEye.y, rightEye.x - leftEye.x);
                    const rollDeg = BABYLON.Tools.ToDegrees(rollRad);

                    // Hat's current rotation
                    const hatRotX = BABYLON.Tools.ToDegrees(hat.rotation.x).toFixed(2);
                    const hatRotY = BABYLON.Tools.ToDegrees(hat.rotation.y).toFixed(2);
                    const hatRotZ = BABYLON.Tools.ToDegrees(hat.rotation.z).toFixed(2);

                    const correctedYaw = yawRad - BABYLON.Tools.ToRadians(90);
                    const correctedPitch = pitchRad + BABYLON.Tools.ToRadians(90);
                    const correctedRoll = rollRad; // Already fine

                    /*const quaternion = BABYLON.Quaternion.RotationYawPitchRoll(
                        correctedYaw,     // Y-axis (inverted for Babylon)
                        correctedPitch,    // X-axis
                        -correctedRoll     // Z-axis (flip for Babylon)
                    );*/

                    const quaternion = BABYLON.Quaternion.RotationYawPitchRoll(
                        BABYLON.Tools.ToRadians((yawDeg + 90)),  // Yaw
                        BABYLON.Tools.ToRadians(-(pitchDeg + 90)),               // Pitch
                        BABYLON.Tools.ToRadians(rollDeg)               // Roll
                    );

                    hat.rotationQuaternion = quaternion;
                    //hat.rotationQuaternion = BABYLON.Quaternion.Slerp(hat.rotationQuaternion, quaternion, 0.2);

                    // üñ•Ô∏è Debug info
                    const debugText = `
                        üëÅÔ∏è Eye Distance: ${eyeDist.toFixed(4)}<br>
                        üß† Forehead Z (raw): ${forehead.z.toFixed(4)}<br>
                        ‚Ü™Ô∏è Head Rotation:<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;Yaw (Y): ${yawDeg.toFixed(2)}¬∞<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;Pitch (X): ${pitchDeg.toFixed(2)}¬∞<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;Roll (Z): ${rollDeg.toFixed(2)}¬∞<br>
                        üé© Hat Position:<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;X: ${hat.position.x}¬∞<br> 
                        &nbsp;&nbsp;&nbsp;&nbsp;Y: ${hat.position.y}¬∞<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;Z: ${hat.position.z}¬∞<br>
                        üé© Hat Rotation:<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;X: ${hat.rotationQuaternion.x}¬∞, Y: ${hat.rotationQuaternion.y}¬∞, Z: ${hat.rotationQuaternion.z}¬∞
                         `;
                    //document.getElementById('debug').innerHTML = debugText;

                    // Apply rotation to the hat
                    //hat.rotation.x = BABYLON.Tools.ToRadians(pitchDeg + 90);     // pitch offset to neutral (looking forward)
                    //hat.rotation.y = BABYLON.Tools.ToRadians(-(yawDeg - 90));     // invert yaw so right is positive
                    //hat.rotation.z = BABYLON.Tools.ToRadians(-rollDeg);  
                }
            }
        });

        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => {
                await faceMesh.send({ image: videoElement });
            },
            width: 480,
            height: 640
        });

        cameraUtils.start();
    </script>
</body>

</html>